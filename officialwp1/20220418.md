# Crypto I Write-Up

Nebula 战队信息安全设计与实践讲义编写组


## 萌新的 CTF
这题有 2 个未知字节，每一个位置字节有 256 种可能的取值，总共 256*256=65536 种可能的取值，因此枚举的时间复杂度是完全能够承受的。

因此我们只需要枚举开头的两个 byte，当符合结果时输出这两个 byte 的 hex 值即可

这里放出示例代码

```python
import hashlib # python 内置库

plaintext_suffix = bytes.fromhex('你得到的后半段 plaintext')
sha256_hex = '你得到的 sha256 值'

for chr1 in range(256):
	for chr2 in range(256):
		plaintext_prefix = bytes([chr1, chr2])
		plaintext = plaintext_prefix + plaintext_suffix
		if hashlib.sha256(plaintext ).hexdigest() == sha256_hex:
			print('[+] Found:', plaintext_prefix.hex())
```
## 牢不可破的多次加密

可以发现，信息被加密一次后为 ac+b, 二次后为 a(ac+b)+b=a²c+ab+b=a'c+b'……

即，最终的信息应当为 Ac+B，与原来的信息为一次函数关系。

此时可以得到两种解法：
1. 【数学】：利用我们已知的明文开头的前两位，列出二元一次同余方程组，解得 A, B 并解密剩下的数据
```python
from Crypto.Util.number import inverse

def decryptAB(info, A, B):
    decrypted = ''
    for c in info:
        val = (A * (ord(c) - ord('a')) + B) % 26
        decrypted += chr(val + ord('a'))
    return decrypted

def decrypt(info):
    x0 = ord('n') - ord('a')
    x1 = ord('e') - ord('a')
    res0 = ord(info[0]) - ord('a')
    res1 = ord(info[1]) - ord('a')
    A = (res1 - res0) *inverse(x1 - x0, 26) % 26
    B = (res0 - A * x0) % 26
```
2. 【爆破】：由于运算在模 26 下进行，可以枚举 A, B 的取值，对每组 A, B 解密出的明文检验开头是否匹配。事实上，为了方便，我们可以等价地枚举 A^-1 与 B^-1 的取值来解密以简化代码
```python
def decryptAB(info, A, B):
    decrypted = ''
    for c in info:
        val = (A * (ord(c) - ord('a')) + B) % 26
        decrypted += chr(val + ord('a'))
    return decrypted

def decrypt(info):
    assert len(info) == 28
    values = list(range(1, 26, 2))
    values.remove(13)
    for A in values:
        for B in range(26):
            if decryptAB(info, A, B).startswith('neverget'):
                print(decryptAB(info, A, B), A, B)
```
## 揭开它们的面纱
显然我们只需要求出 ``[[4, 7], [2, 6]]`` 在模 137 意义下的逆矩阵，并将其左乘上输出的矩阵就行了。求逆矩阵的方法？手算即可，是 ``[[28, 13], [82, 110]]``

然后输出格式可能略微有些阴间，不过我们还是可以一通操作将其转换回去。

不过，其实我们完全不需要思考代码的写法。题目的序列 - 矩阵转换方式是完全对称的，所以只要把题目的 flag 改成输出，再把加密矩阵 M 改掉，就能获得我们的答案了，出题人是不是很良心呢
```python
import numpy as np

cipher = '你得到的输出'
assert len(cipher) % 2 == 0
data = bytes.fromhex(cipher)

M = [[28, 13], [82, 110]]
# 下方除输出外和部分细节外，跟题面几乎完全一致
D1 = [data[i] for i in range(0, len(data), 2)]
D2 = [data[i] for i in range(1, len(data), 2)]
ans = np.matmul(np.array(M), np.array([D1, D2]))
result = ''
for i in range(len(data) // 2):
	result += chr(ans[0, i] % 137)
	result += chr(ans[1, i] % 137)
print(f'flag{{{result}}}')
```

## AES ECB Mode

真是一道无情的题目（叹气）连题目名都没好好取。

这题的难度配不上其分值（doge）只要知道 AES 库的用法就可以轻松秒杀
```python
#!/usr/bin/env python3
from Crypto.Cipher import AES

cipher = bytes.fromhex('你得到的输出')
key = b'cyber2022_GPA4.3'

aes = AES.new(key, AES.MODE_ECB)
print(aes.decrypt(flag).decode())
```

## AES CBC Mode
这道题本来还有一个第二小问，不过现在已经变成了讲义上的附加题。

做法很简单：我们知道 ``block-cipher-encrypt(plaintext ^ iv) = cipher``，并且其中 ``iv`` 与 ``cipher`` 是我们可以控制的。对我们来说，控制 ``cipher`` 是困难的，但我们最终的目的是让 ``block-cipher-encrypt(expected_text ^ new_iv) = new_cipher``。

我们可以保证 ``new_cipher = cipher``，此时有 ``plaintext ^ iv = expected_text ^ new_iv``。那么取 ``new_iv = plaintext ^ iv ^ expected_text`` 即可满足要求。

我们可以写这样一个函数实现异或：
```python
from Crypto.Util.number import long_to_bytes, bytes_to_long

def bytes_xor(lis):
    result = 0
    for x in lis:
        result ^= bytes_to_long(x)
    return long_to_bytes(result)
```
那么我们调用 ``bytes_xor([message, expected, bytes.fromhex(iv)]).hex()`` 即可得到 flag