萌新觉得这题太简单，懒得写题解了（悲

所以某个（自封的）验题人来写一下他的乱搞经历。验题人除了在 Hackergame 2021 用过一次 IDA 之外就没有其他逆向经历了。

### Final Trial

拖进 IDA，通过字符串的交叉引用找程序的主要逻辑：

![image-20220518225141586](.\1.png)

容易发现 `sub_401648` 函数对读入的 flag 做了一些处理，flag 的长度为 43，处理之后的 flag 与 `unk_410040` 进行比较，若相等则说明 flag 正确。下面是 `byte_410040` 的内容，不出意外地是个 `char[43]` 的数组，ASCII 码无法直接翻译出可见字符。

![image-20220518225852933](.\2.png)

可以进处理 flag 的函数看一下。

看了半天，逻辑完全看不懂。发现 `byte_410080` 是一个固定值的 `char[192]` 数组，又发现下面有一大堆 switch 语句，猜测这是用于构成程序控制流的部分，但逻辑还是很混乱，尝试把函数整个截下来复现也很困难。

这时我注意到函数的这一部分：

![image-20220518230400040](.\3.png)

case 11 应该是宣告加密结束，然后将加密后的数组复制回原来的数组吧？那我们不如试试看，把这整个加密逻辑看成一个黑盒，直接在加密结束之后打个断点，多输入几组数据，看看加密后的结果和明文有什么关系，暴力猜测它的加密方式？

（一个很重要的理由是，我在写这题之前打 CTF 的时候用过这种手法（没错，就是 MRCTF 2022 的 Misc 题），也成功猜出了加密逻辑，那个猜起来可比这个难。。。）

我使用的是 IDA 提供的动调功能，打断点很方便，和普通的 IDE 一样，直接在需要暂停的语句旁边点一下就可以了。

断点最后设在了这个地方，虽说可以看汇编打一个更精细的断点，不过我懒了，而且我也不怎么会用 IDA 调汇编。

![image-20220518231340428](.\4.png)

进入调试界面，flag 打个 `1` 进去，通过变量名跳转到对应的内存地址，改变量类型，加入 watch point，然后狂按 F9。

初始状态：

![image-20220518231900204](.\5.png)

加密后的状态：

![image-20220518232041049](.\6.png)

然后再调一遍，这次 flag 打个 `2` 进去，同样的操作再来一遍。

加密前的状态：

![image-20220518232839024](.\7.png)

加密后的状态：

![image-20220518232203669](.\8.png)

稍微敏感一点就知道这是异或加密，写个程序跑一下就出来了。

### 后记

后来向 “萌新” 请教的时候才知道这是个虚拟机，使用了类似汇编语言的方式对命令进行了编码，正面做是十分困难而且没必要的，因为需要提取出所有命令并用类似汇编的方式翻译出来，甚至还有 jmp 指令搁那跳来跳去的。

感觉不如动调。。。简单程度（